// Code generated by "{{.Cmd}}"; DO NOT EDIT.

package {{.PackageName}}

{{if .Imports}}
import (
	{{.Imports}}
)
{{end}}
{{if .Json -}}
import "encoding/json"
{{- end}}
{{if .Option -}}
import "github.com/lopolopen/shoot"
{{- end}}

// New{{.TypeName}} constructs a new instance of type {{.TypeName}}
func New{{.TypeName}}({{range .NewList}}{{.}} {{typeof .}},{{end}}) *{{.TypeName}} {
	return &{{.TypeName}}{ 
		{{range .NewList -}}
		{{.}}: {{.}},
		{{end}}
	}
}

{{if .Option}}
// With initializes this instance using the functional options pattern
func ({{firstLower .TypeName}} *{{.TypeName}})With(opts ...shoot.Option[{{.TypeName}}, *{{.TypeName}}]) *{{.TypeName}} { 
	{{firstLower .TypeName}}.SetDefault()
	for _, opt := range opts {
        opt({{firstLower .TypeName}})
    }
    return {{firstLower .TypeName}}
}

{{range .AllList -}}
// {{pascalCase .}}Of{{$.TypeName}} is a configuration for the filed {{.}}
func {{pascalCase .}}Of{{$.TypeName}}({{camelCase .}}_ {{typeof .}})shoot.Option[{{$.TypeName}}, *{{$.TypeName}}] {
	 return func({{firstLower $.TypeName}} *{{$.TypeName}}) {
        {{firstLower $.TypeName}}.{{.}} = {{camelCase .}}_ 
    }
}
{{end}}

// SetDefault sets the default values
func ({{firstLower .TypeName}} *{{.TypeName}})SetDefault(){
	{{- range .DefaultList -}}
	{{firstLower $.TypeName}}.{{.}} = {{defaultof .}}{{"\n"}}
	{{- end -}}
}
{{- end}}


{{if .GetSet}}
{{range .GetterList -}}
// {{pascalCase .}} gets the value of field {{.}}
func ({{firstLower $.TypeName}} *{{$.TypeName}}){{pascalCase .}}() {{typeof .}} {
	return {{firstLower $.TypeName}}.{{.}}
}
{{end}}

{{range .SetterList}}
// Set{{pascalCase .}} sets the value of field {{.}}
func ({{firstLower $.TypeName}} *{{$.TypeName}})Set{{pascalCase .}}({{.}}_ {{typeof .}}) {
	{{firstLower $.TypeName}}.{{.}} = {{.}}_
}
{{end}}
{{end}}

{{if .Json}}
type _{{.TypeName}}_marshal struct { 
	{{range .GetterList -}}
	{{pascalCase .}} {{typeof .}}{{if (jsontagof .)}}`json:"{{jsontagof .}}"`{{end}}{{"\n"}}
	{{- end}}
	{{range $.ExportedList}} 
	{{pascalCase .}} {{typeof .}} {{if (jsontagof .)}}`json:"{{jsontagof .}}"`{{end}}{{"\n"}}
	{{- end}}
}

type _{{.TypeName}}_unmarshal struct { 
	{{range .SetterList -}}
	{{pascalCase .}} {{typeof .}} {{if (jsontagof .)}}`json:"{{jsontagof .}}"`{{end}}{{"\n"}}
	{{- end}}
	{{range .ExportedList -}}
	{{pascalCase .}} {{typeof .}} {{if (jsontagof .)}}`json:"{{jsontagof .}}"`{{end}}{{"\n"}}
	{{- end}}
}

// MarshalJSON serializes type {{.TypeName}} to json bytes
func ({{firstLower .TypeName}} {{.TypeName}})MarshalJSON()([]byte, error) {
	data := _{{.TypeName}}_marshal{ 
		{{range .GetterList -}}
		{{pascalCase .}}: {{firstLower $.TypeName}}.{{pascalCase .}}(),{{"\n"}}
		{{- end}}
		{{range .ExportedList -}}
		{{.}}: {{firstLower $.TypeName}}.{{.}},{{"\n"}}
		{{- end}}
	}
	{{if not .EmbedList -}}
	return json.Marshal(data)
	{{- else}}
	values := make(map[string]interface{})
	{{range $i, $v := .EmbedList -}}
	j{{$i}}, err := json.Marshal({{firstLower $.TypeName}}.{{$v}})
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(j{{$i}}, &values)
	if err != nil {
		return nil, err
	}
	{{- end}}
	j, err := json.Marshal(data)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(j, &values)
	if err != nil {
		return nil, err
	}
	return json.Marshal(values)
	{{- end}}
}

// UnmarshalJSON deserializes json bytes to type {{.TypeName}}
func ({{firstLower .TypeName}} *{{.TypeName}})UnmarshalJSON(data []byte) error {
	var {{camelCase .TypeName}}_ _{{.TypeName}}_unmarshal
	if err := json.Unmarshal(data, &{{camelCase .TypeName}}_); err != nil {
		return err
	}
	{{range .SetterList -}}
	{{firstLower $.TypeName}}.Set{{pascalCase .}}({{camelCase $.TypeName}}_.{{pascalCase .}}){{"\n"}}
	{{- end}}
	{{range .ExportedList -}}
	{{firstLower $.TypeName}}.{{.}} = {{camelCase $.TypeName}}_.{{.}}{{"\n"}}
	{{- end}} 
	{{if .EmbedList -}}
	all := make(map[string]interface{})
	err := json.Unmarshal(data, &all)
	if err != nil {
		return err
	}
	j, err := json.Marshal({{camelCase .TypeName}}_ )
	if err != nil {
		return err
	}
	some := make(map[string]interface{})
	err = json.Unmarshal(j, &some)
	if err != nil {
		return err
	}
	for key := range some {
		delete(all, key)
	}
	jrest, err := json.Marshal(all)
	if err != nil {
		return err
	}
	{{range .EmbedList -}}
		err = json.Unmarshal(jrest, &{{firstLower $.TypeName}}.{{.}})
		if err != nil {
			return err
		}
	{{- end}}
	{{- end}}
	return nil
}
{{end}}