{{- $this := firstLower .TypeName -}}
{{- $shoot := "shoot." -}}
{{- if .Self -}}
{{- $shoot = "" -}}
{{- end -}}
{{- $TypeName := .TypeName -}}
{{- $NewFuncName := printf "New%s" .TypeName -}}
{{- $Getter := printf "%sGetter" .TypeName -}}
{{- $Setter := printf "%sSetter" .TypeName -}}
{{- $Marshal := printf "_marshal_%s" .TypeName -}}
{{- $Unmarshal := printf "_unmarshal_%s" .TypeName -}}
{{- if .TypeParamList -}}
{{- $TypeName = printf "%s[%s]" $TypeName .TypeParamNameList -}}
{{- $NewFuncName = printf "%s[%s]" $NewFuncName .TypeParamList -}}
{{- $Getter = printf "%s[%s]" $Getter .TypeParamList -}}
{{- $Setter = printf "%s[%s]" $Setter .TypeParamList -}}
{{- $Marshal = printf "_marshal_%s[%s]" .TypeName .TypeParamList -}} 
{{- $Unmarshal = printf "_unmarshal_%s[%s]" .TypeName .TypeParamList -}}
{{- end -}}

// Code generated by "{{.CmdLine}}"; DO NOT EDIT. ({{.Version}})

package {{.PackageName}}

{{if .Imports}}
import (
	{{.Imports}}
) {{"\n"}}
{{- end -}}
{{- if .JSON -}}
import "encoding/json" {{"\n"}}
{{- end -}}
{{- if and .Option (not .Self) -}}
import "github.com/lopolopen/shoot" {{"\n"}}
{{- end}}

// {{$NewFuncName}} constructs a new instance of type {{$TypeName}}
func {{$NewFuncName}}({{.NewParamsList}}) *{{$TypeName}} {
	return &{{$TypeName}}{
		{{.NewBody}}
	}
}

{{if .Option}}
// With initializes this instance using the functional options pattern
func ({{$this}} *{{$TypeName}})With(opts ...{{$shoot}}Option[{{$TypeName}}, *{{$TypeName}}]) *{{$TypeName}} { {{"\n"}}
	{{- if .DefaultList -}}
	{{$this}}.SetDefault() {{"\n"}}
	{{- end -}}
	for _, opt := range opts {
        opt({{$this}})
    }
    return {{$this}}
}

{{range .AllList -}}
{{- $fname := pascalCase . -}}
{{- if not $.Short -}}
{{- $fname = printf "%s%s%s" (pascalCase .) "Of" $TypeName -}}
{{- end -}}
// {{$fname }} is a configuration for the filed {{.}}
func {{$fname}}({{camelCase .}}_ {{index $.TypeMap .}}){{$shoot}}Option[{{$TypeName}}, *{{$TypeName}}] {
	 return func({{$this}} *{{$TypeName}}) {
        {{$this}}.{{.}} = {{camelCase .}}_ 
    }
} {{"\n"}}
{{- end -}} {{"\n"}}

{{- if .DefaultList -}}
// SetDefault sets the default values
func ({{$this}} *{{$TypeName}})SetDefault(){ {{"\n"}}
	{{- range .DefaultList -}}
	{{$this}}.{{.}} = {{index $.DefaultValueMap .}} {{"\n"}}
	{{- end -}}
} {{"\n"}}
{{- end -}}
{{- end -}} {{"\n"}}

{{- if .GetSet -}}
{{- range .GetterList -}}
// {{pascalCase .}} gets the value of field {{.}}
func ({{$this}} *{{$TypeName}}){{pascalCase .}}() {{index $.TypeMap .}} {
	return {{$this}}.{{.}}
} {{"\n"}}
{{- end -}}

{{- range .SetterList -}}
// Set{{pascalCase .}} sets the value of field {{.}}
func ({{$this}} *{{$TypeName}})Set{{pascalCase .}}({{.}}_ {{index $.TypeMap .}}) {
	{{$this}}.{{.}} = {{.}}_
} {{"\n"}}
{{- end -}}
{{- end -}}

{{- if .JSON -}}
type {{$Marshal}} struct { {{"\n"}}
	{{- range .GetterList -}}
	{{- $jsontag := index $.JSONTagMap . -}}
	{{pascalCase .}} {{index $.TypeMap .}}{{if $jsontag}}`json:"{{$jsontag}}"`{{end}} {{"\n"}}
	{{- end -}}
	{{- range $.ExportedList -}} 
	{{- $jsontag := index $.JSONTagMap . -}}
	{{pascalCase .}} {{index $.TypeMap .}} {{if $jsontag}}`json:"{{$jsontag}}"`{{end}} {{"\n"}}
	{{- end -}}
}

type {{$Unmarshal}} struct { {{"\n"}}
	{{- range .SetterList -}}
	{{- $jsontag := index $.JSONTagMap . -}}
	{{pascalCase .}} {{index $.TypeMap .}} {{if $jsontag}}`json:"{{$jsontag}}"`{{end}} {{"\n"}}
	{{- end -}}
	{{- range .ExportedList -}}
	{{- $jsontag := index $.JSONTagMap . -}}
	{{pascalCase .}} {{index $.TypeMap .}} {{if $jsontag}}`json:"{{$jsontag}}"`{{end}} {{"\n"}}
	{{- end -}}
}

// MarshalJSON serializes type {{$TypeName}} to json bytes
func ({{$this}} {{$TypeName}})MarshalJSON()([]byte, error) {
	data := _marshal_{{$TypeName}}{  {{"\n"}}
		{{- range .GetterList -}}
		{{pascalCase .}}: {{$this}}.{{pascalCase .}}(),{{"\n"}}
		{{- end -}}
		{{- range .ExportedList -}}
		{{.}}: {{$this}}.{{.}},{{"\n"}}
		{{- end -}}
	} {{"\n"}}
	{{- if not .EmbedList -}}
	return json.Marshal(data)
	{{- else -}}
	values := make(map[string]interface{}) {{"\n"}}
	{{- range $i, $v := .EmbedList -}}
	j{{$i}}, err := json.Marshal({{$this}}.{{$v}})
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(j{{$i}}, &values)
	if err != nil {
		return nil, err
	} {{"\n"}}
	{{- end -}}
	j, err := json.Marshal(data)
	if err != nil {
		return nil, err
	}
	err = json.Unmarshal(j, &values)
	if err != nil {
		return nil, err
	}
	return json.Marshal(values) {{"\n"}}
	{{- end -}}
}

// UnmarshalJSON deserializes json bytes to type {{$TypeName}}
func ({{$this}} *{{$TypeName}})UnmarshalJSON(data []byte) error {
	var {{camelCase $.TypeName}}_ _unmarshal_{{$TypeName}}
	if err := json.Unmarshal(data, &{{camelCase $.TypeName}}_); err != nil {
		return err
	} {{"\n"}}
	{{- range .SetterList -}}
	{{$this}}.Set{{pascalCase .}}({{camelCase $.TypeName}}_.{{pascalCase .}}) {{"\n"}}
	{{- end -}}
	{{- range .ExportedList -}}
	{{$this}}.{{.}} = {{camelCase $.TypeName}}_.{{.}} {{"\n"}}
	{{- end -}} 
	{{- if .EmbedList -}}
	all := make(map[string]interface{})
	err := json.Unmarshal(data, &all)
	if err != nil {
		return err
	}
	j, err := json.Marshal({{camelCase $.TypeName}}_ )
	if err != nil {
		return err
	}
	some := make(map[string]interface{})
	err = json.Unmarshal(j, &some)
	if err != nil {
		return err
	}
	for key := range some {
		delete(all, key)
	}
	jrest, err := json.Marshal(all)
	if err != nil {
		return err
	} {{"\n"}}
	{{- range .EmbedList -}}
	err = json.Unmarshal(jrest, &{{$this}}.{{.}})
	if err != nil {
		return err
	} {{"\n"}}
	{{- end -}}
	{{- end -}}
	return nil
}
{{end}}

{{if .GetSet -}}
// {{$Getter}} is read-only interface for {{$TypeName}} type
type {{$Getter}} interface { {{"\n"}}
	{{- range $.GetterIfaces -}}
	{{.}} {{"\n"}}
	{{- end -}}
	{{- range .GetterList -}}
	{{pascalCase .}}() {{index $.TypeMap .}} {{"\n"}}
	{{- end -}}
} 

// {{$Setter}} is write-only interface for {{$TypeName}} type
type {{$Setter}} interface { {{"\n"}}
	{{- range $.SetterIfaces -}}
	{{.}} {{"\n"}}
	{{- end -}}
	{{- range .GetterList -}}
	Set{{pascalCase .}}({{index $.TypeMap .}}) {{"\n"}}
	{{- end -}}
}
{{- end}}

// ShootNew exists solely to fulfill the NewShooter interface contract
func ({{$this}} {{$TypeName}}) ShootNew() { /*noop*/ }