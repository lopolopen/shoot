{{- $this := firstLower .TypeName -}}

// Code generated by "{{.CmdLine}}"; DO NOT EDIT. ({{.Version}})

package {{.PackageName}}

{{if .JSON -}}
import "encoding/json" {{"\n"}}
{{- end -}}
{{- if .SQL -}}
import "database/sql/driver" {{"\n"}}
{{- end -}}
{{- if or .JSON .Text .SQL -}}
import "github.com/lopolopen/shoot" {{"\n"}}
{{- end -}}
{{- if .Gorm -}}
import "gorm.io/gorm"
import "gorm.io/gorm/schema"
{{- end}}

func _() {
	var x [1]struct{} {{"\n"}}
	{{- range .NameList -}}
	_ = x[{{.}}-{{valueof .}}] {{"\n"}}
	{{- end -}}
}

const _{{camelCase .TypeName}}_max = {{.Max}}

var _{{camelCase .TypeName}}_values = []{{.TypeName}}{ {{range .NameList}}{{.}}, {{end}} }

var _{{camelCase .TypeName}}_strings = []string{ {{range .NameList}}"{{strof .}}", {{end}} }

var _{{camelCase .TypeName}}_string_map = map[{{.TypeName}}]string { {{"\n"}}
	{{- range .NameList -}}
	{{.}}: "{{strof .}}", {{"\n"}}
	{{- end -}}
}

var _{{camelCase .TypeName}}_value_map = map[string]{{.TypeName}} { {{"\n"}}
	{{- range .NameList -}}
	"{{strof .}}": {{.}}, {{"\n"}}
	{{- end -}}
}

// String returns the string value of type {{.TypeName}}
func ({{$this}} {{.TypeName}}) String() string {
	str, ok := _{{camelCase .TypeName}}_string_map[{{$this}}]
	if ok {
		return str
	}
	if {{$this}} < 0 || {{$this}} > _{{camelCase .TypeName}}_max {
		return fmt.Sprintf("%d", {{$this}})
	}
	{{if .Bitwise}}
	var buf bytes.Buffer
	{{$this}}_ := {{$this}}
	for i_ := 0; i_ < len(_{{camelCase .TypeName}}_values); i_++ {
		v_ := _{{camelCase .TypeName}}_values[i_]
		if v_ == 0 {
			continue
		}
		if {{$this}}_ == 0 {
			break
		}
		if {{$this}}_.Has(v_) {
			fmt.Fprintf(&buf, ", %s", _{{camelCase .TypeName}}_map[v_])
			{{$this}}_ = {{$this}}_.Remove(v_)
		}
	}
	if {{$this}}_ == 0 && buf.Len() > 0 {
		return string(buf.Bytes()[2:])
	}
	{{end}}
	return fmt.Sprintf("%d", {{$this}})
}

func ({{$this}} {{.TypeName}}) Values() []{{.TypeName}} {
	return _{{camelCase .TypeName}}_values
}

func ({{$this}} {{.TypeName}}) Strings() []string {
	return _{{camelCase .TypeName}}_strings
}

func ({{$this}} {{.TypeName}}) IsValid() bool {
	_, ok := _{{camelCase .TypeName}}_string_map[{{$this}}]
	return ok
}

func ({{$this}} {{.TypeName}}) ValueMap() map[string]{{.TypeName}} {
	return _{{camelCase .TypeName}}_value_map
}

func ({{$this}} {{.TypeName}}) StringMap() map[{{.TypeName}}]string {
	return _{{camelCase .TypeName}}_string_map
}

{{if .JSON}}
// MarshalJSON implements the json.Marshaler interface for {{.TypeName}}
func ({{$this}} {{.TypeName}}) MarshalJSON() ([]byte, error) {
	return json.Marshal({{$this}}.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for {{.TypeName}}
func ({{$this}} *{{.TypeName}}) UnmarshalJSON(data []byte) error {
	var s_ string
	var v_ {{.TypeName}}
	var err error
	if err = json.Unmarshal(data, &s_); err != nil {
		return fmt.Errorf("{{.TypeName}} enum should be a string, got %s", data)
	}
	if v_, err = shoot.ParseEnum[{{.TypeName}}](s_); err != nil {
		return err
	}
	*{{$this}} = v_
	return nil
}
{{end}}

{{if .Text}}
// MarshalText implements the encoding.TextMarshaler interface for {{.TypeName}}
func ({{$this}} {{.TypeName}}) MarshalText() ([]byte, error) {
	return []byte({{$this}}.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for {{.TypeName}}
func ({{$this}} *{{.TypeName}}) UnmarshalText(text []byte) error {
	var v_ {{.TypeName}}
	var err error
	if v_, err = shoot.ParseEnum[{{.TypeName}}](string(text)); err != nil {
		return err
	}
	*{{$this}} = v_
	return nil
}
{{end}}

{{if .SQL}}
//Value implements the driver.Valuer interface for {{.TypeName}}
func ({{$this}} {{.TypeName}}) Value() (driver.Value, error) {
	return {{$this}}.String(), nil
}

//Scan implements the driver.Scanner interface for {{.TypeName}}
func ({{$this}} *{{.TypeName}}) Scan(value interface{}) error {
	data, ok := value.([]byte)
	if !ok {
		return errors.New("bad enum type")
	}
	e_, err := shoot.ParseEnum[{{.TypeName}}](string(data))
	if err != nil {
		return err
	}
	*{{$this}}  = e_
	return nil
}
{{end}}

{{if .Gorm}}
// GormDataType specifies the general data type that GORM should treat this field as.
func ({{$this}} {{.TypeName}}) GormDataType() string {
	return "string"
}

// GormDBDataType provides the exact database column type definition for this field.
func ({{$this}} {{.TypeName}}) GormDBDataType(db *gorm.DB, field *schema.Field) string {
	return "ENUM({{.Enums}})"
}
{{end}}

{{if .Bitwise}}
// Has checks if a specific flag is present in the {{.TypeName}} set
func ({{$this}} {{.TypeName}}) Has(flag {{.TypeName}}) bool {
	return {{$this}}&flag == flag
}

// Add adds a flag to the {{.TypeName}} set
func ({{$this}} {{.TypeName}}) Add(flag {{.TypeName}}) {{.TypeName}} {
	return {{$this}} | flag
}

// Remove removes a flag from the {{.TypeName}} set
func ({{$this}} {{.TypeName}}) Remove(flag {{.TypeName}}) {{.TypeName}} {
	return {{$this}} &^ flag 
}
{{end}}

// ShootEnum exists solely to fulfill the EnumShooter interface contract
func ({{$this}} {{.TypeName}}) ShootEnum() { /*noop*/ }