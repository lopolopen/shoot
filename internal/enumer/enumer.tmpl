// Code generated by "{{.Cmd}}"; DO NOT EDIT.

package {{.PackageName}}

{{if .Json -}}
import "encoding/json"
{{- end}}
{{if or .Json .Text -}}
import "github.com/lopolopen/shoot"
{{- end}}

func _() {
	var x [1]struct{}
	{{range .NameList -}}
	_ = x[{{.}}-{{valueof .}}]{{"\n"}}
	{{- end}}
}

const _{{camelCase .TypeName}}_all = {{range .NameList}}{{.}} |{{end}}0

var _{{camelCase .TypeName}}_values = []{{.TypeName}}{ {{range .NameList}}{{.}}, {{end}} }

var _{{camelCase .TypeName}}_strings = []string{ {{range .NameList}}"{{strof .}}", {{end}} }

var _{{camelCase .TypeName}}_string_map = map[{{.TypeName}}]string{
	{{range .NameList -}}
	{{.}}: "{{strof .}}",{{"\n"}}
	{{- end}}
}

var _{{camelCase .TypeName}}_value_map = map[string]{{.TypeName}}{
	{{range .NameList -}}
	"{{strof .}}": {{.}},{{"\n"}}
	{{- end}}
}

// String returns the string value of type {{.TypeName}}
func ({{firstLower .TypeName}} {{.TypeName}}) String() string {
	str, ok := _{{camelCase .TypeName}}_string_map[{{firstLower .TypeName}}]
	if ok {
		return str
	}
	if {{firstLower .TypeName}} < 0 || {{firstLower .TypeName}} > _{{camelCase .TypeName}}_all {
		return fmt.Sprintf("%d", {{firstLower .TypeName}})
	}
	{{if .Bitwise}}
	var buf bytes.Buffer
	{{firstLower .TypeName}}_ := {{firstLower .TypeName}}
	for i_ := 0; i_ < len(_{{camelCase .TypeName}}_values); i_++ {
		v_ := _{{camelCase .TypeName}}_values[i_]
		if v_ == 0 {
			continue
		}
		if {{firstLower .TypeName}}_ == 0 {
			break
		}
		if {{firstLower .TypeName}}_.Has(v_) {
			fmt.Fprintf(&buf, ", %s", _{{camelCase .TypeName}}_map[v_])
			{{firstLower .TypeName}}_ = {{firstLower .TypeName}}_.Remove(v_)
		}
	}
	if {{firstLower .TypeName}}_ == 0 && buf.Len() > 0 {
		return string(buf.Bytes()[2:])
	}
	{{end}}
	return fmt.Sprintf("%d", {{firstLower .TypeName}})
}

func ({{firstLower .TypeName}} {{.TypeName}}) Values() []{{.TypeName}} {
	return _{{camelCase .TypeName}}_values
}

func ({{firstLower .TypeName}} {{.TypeName}}) Strings() []string {
	return _{{camelCase .TypeName}}_strings
}

func ({{firstLower .TypeName}} {{.TypeName}}) ValueMap() map[string]{{.TypeName}} {
	return _{{camelCase .TypeName}}_value_map
}

func ({{firstLower .TypeName}} {{.TypeName}}) StringMap() map[{{.TypeName}}]string {
	return _{{camelCase .TypeName}}_string_map
}

{{if .Json}}
// MarshalJSON implements the json.Marshaler interface for {{.TypeName}}
func ({{firstLower .TypeName}} {{.TypeName}}) MarshalJSON() ([]byte, error) {
	return json.Marshal({{firstLower .TypeName}}.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for {{.TypeName}}
func ({{firstLower .TypeName}} *{{.TypeName}}) UnmarshalJSON(data []byte) error {
	var s_ string
	var v_ {{.TypeName}}
	var err error
	if err = json.Unmarshal(data, &s_); err != nil {
		return fmt.Errorf("{{.TypeName}} enum should be a string, got %s", data)
	}

	if v_, err = shoot.ParseEnum[{{.TypeName}}](s_); err != nil {
		return err
	}
	*{{firstLower .TypeName}} = v_
	return nil
}
{{end}}

{{if .Text}}
// MarshalText implements the encoding.TextMarshaler interface for {{.TypeName}}
func ({{firstLower .TypeName}} {{.TypeName}}) MarshalText() ([]byte, error) {
	return []byte({{firstLower .TypeName}}.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for {{.TypeName}}
func ({{firstLower .TypeName}} *{{.TypeName}}) UnmarshalText(text []byte) error {
	var v_ {{.TypeName}}
	var err error
	if v_, err = shoot.ParseEnum[{{.TypeName}}](string(text)); err != nil {
		return err
	}
	*{{firstLower .TypeName}} = v_
	return nil
}
{{end}}

{{if .Bitwise}}
// Has checks if a specific flag is present in the {{.TypeName}} set
func ({{firstLower $.TypeName}} {{.TypeName}}) Has(flag {{.TypeName}}) bool {
	return {{firstLower $.TypeName}}&flag == flag
}

// Add adds a flag to the {{.TypeName}} set
func ({{firstLower $.TypeName}} {{.TypeName}}) Add(flag {{.TypeName}}) {{.TypeName}} {
	return {{firstLower $.TypeName}} | flag
}

// Remove removes a flag from the {{.TypeName}} set
func ({{firstLower $.TypeName}} {{.TypeName}}) Remove(flag {{.TypeName}}) {{.TypeName}} {
	return {{firstLower $.TypeName}} &^ flag 
}
{{end}}
