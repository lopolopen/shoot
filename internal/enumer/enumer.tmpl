{{- $this := firstLower .TypeName -}}

// Code generated by "{{.Cmd}}"; DO NOT EDIT.

package {{.PackageName}}

{{if .Json -}}
import "encoding/json"
{{- end}}
{{if or .Json .Text -}}
import "github.com/lopolopen/shoot"
{{- end}}

func _() {
	var x [1]struct{}
	{{range .NameList -}}
	_ = x[{{.}}-{{valueof .}}]{{"\n"}}
	{{- end}}
}

const _{{camelCase .TypeName}}_all = {{range .NameList}}{{.}} |{{end}}0

var _{{camelCase .TypeName}}_values = []{{.TypeName}}{ {{range .NameList}}{{.}}, {{end}} }

var _{{camelCase .TypeName}}_strings = []string{ {{range .NameList}}"{{strof .}}", {{end}} }

var _{{camelCase .TypeName}}_string_map = map[{{.TypeName}}]string{
	{{range .NameList -}}
	{{.}}: "{{strof .}}",{{"\n"}}
	{{- end}}
}

var _{{camelCase .TypeName}}_value_map = map[string]{{.TypeName}}{
	{{range .NameList -}}
	"{{strof .}}": {{.}},{{"\n"}}
	{{- end}}
}

// String returns the string value of type {{.TypeName}}
func ({{$this}} {{.TypeName}}) String() string {
	str, ok := _{{camelCase .TypeName}}_string_map[{{$this}}]
	if ok {
		return str
	}
	if {{$this}} < 0 || {{$this}} > _{{camelCase .TypeName}}_all {
		return fmt.Sprintf("%d", {{$this}})
	}
	{{if .Bitwise}}
	var buf bytes.Buffer
	{{$this}}_ := {{$this}}
	for i_ := 0; i_ < len(_{{camelCase .TypeName}}_values); i_++ {
		v_ := _{{camelCase .TypeName}}_values[i_]
		if v_ == 0 {
			continue
		}
		if {{$this}}_ == 0 {
			break
		}
		if {{$this}}_.Has(v_) {
			fmt.Fprintf(&buf, ", %s", _{{camelCase .TypeName}}_map[v_])
			{{$this}}_ = {{$this}}_.Remove(v_)
		}
	}
	if {{$this}}_ == 0 && buf.Len() > 0 {
		return string(buf.Bytes()[2:])
	}
	{{end}}
	return fmt.Sprintf("%d", {{$this}})
}

func ({{$this}} {{.TypeName}}) Values() []{{.TypeName}} {
	return _{{camelCase .TypeName}}_values
}

func ({{$this}} {{.TypeName}}) Strings() []string {
	return _{{camelCase .TypeName}}_strings
}

func ({{$this}} {{.TypeName}}) ValueMap() map[string]{{.TypeName}} {
	return _{{camelCase .TypeName}}_value_map
}

func ({{$this}} {{.TypeName}}) StringMap() map[{{.TypeName}}]string {
	return _{{camelCase .TypeName}}_string_map
}

{{if .Json}}
// MarshalJSON implements the json.Marshaler interface for {{.TypeName}}
func ({{$this}} {{.TypeName}}) MarshalJSON() ([]byte, error) {
	return json.Marshal({{$this}}.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for {{.TypeName}}
func ({{$this}} *{{.TypeName}}) UnmarshalJSON(data []byte) error {
	var s_ string
	var v_ {{.TypeName}}
	var err error
	if err = json.Unmarshal(data, &s_); err != nil {
		return fmt.Errorf("{{.TypeName}} enum should be a string, got %s", data)
	}

	if v_, err = shoot.ParseEnum[{{.TypeName}}](s_); err != nil {
		return err
	}
	*{{$this}} = v_
	return nil
}
{{end}}

{{if .Text}}
// MarshalText implements the encoding.TextMarshaler interface for {{.TypeName}}
func ({{$this}} {{.TypeName}}) MarshalText() ([]byte, error) {
	return []byte({{$this}}.String()), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface for {{.TypeName}}
func ({{$this}} *{{.TypeName}}) UnmarshalText(text []byte) error {
	var v_ {{.TypeName}}
	var err error
	if v_, err = shoot.ParseEnum[{{.TypeName}}](string(text)); err != nil {
		return err
	}
	*{{$this}} = v_
	return nil
}
{{end}}

{{if .Bitwise}}
// Has checks if a specific flag is present in the {{.TypeName}} set
func ({{$this}} {{.TypeName}}) Has(flag {{.TypeName}}) bool {
	return {{$this}}&flag == flag
}

// Add adds a flag to the {{.TypeName}} set
func ({{$this}} {{.TypeName}}) Add(flag {{.TypeName}}) {{.TypeName}} {
	return {{$this}} | flag
}

// Remove removes a flag from the {{.TypeName}} set
func ({{$this}} {{.TypeName}}) Remove(flag {{.TypeName}}) {{.TypeName}} {
	return {{$this}} &^ flag 
}
{{end}}

// ShootEnum exists solely to fulfill the EnumShooter interface contract
func ({{$this}} {{.TypeName}}) ShootEnum() { /*noop*/ }