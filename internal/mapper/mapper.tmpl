{{- $src := firstLower .TypeName -}}
{{- $dest := printf "%s_" (camelCase .DestTypeName) -}}
{{- $to := printf "To%s" (pascalCase .DestPkgName) -}}
{{- $from := printf "From%s" (pascalCase .DestPkgName) -}}
{{- if .DestPkgAlias -}}
{{- $to = printf "To%s" (pascalCase .DestPkgAlias) -}}
{{- $from = printf "From%s" (pascalCase .DestPkgAlias) -}}
{{- end -}}

// Code generated by "{{.CmdLine}}"; DO NOT EDIT.

package {{.PackageName}}

{{if .DestPkgAlias}}
import {{.DestPkgAlias}} "{{.DestPkgPath}}"
{{end}}

// {{$to}} converts receiver to type {{.QualifiedDestTypeName}}
func ({{$src}} *{{.TypeName}}) {{$to}}() *{{.QualifiedDestTypeName}} {
    {{$dest}} := new({{.QualifiedDestTypeName}}) {{"\n"}}
    {{- range $s := $.SrcFieldList -}}

    {{- $d := index $.ExactMatchMap $s -}}
    {{- if $d -}}
    {{$dest}}.{{$d}} = {{$src}}.{{$s}}{{"\n"}}
    {{- end -}}

    {{- $type := index $.SrcToDestTypeMap $s -}}
    {{- if $type -}}
    {{$dest}}.{{index $.ConvMatchMap $s}} = {{$type}}({{$src}}.{{$s}}) {{"\n"}}
    {{- end -}}

    {{- $func := index $.SrcToDestFuncMap $s -}}
    {{- if $func -}}
    {{$dest}}.{{index $.MismatchFuncMap $s}} = {{$src}}.{{$func}}({{$src}}.{{$s}}) {{"\n"}}
    {{- end -}}

    {{- $d := index $.MismatchSubMap $s -}}
    {{- if $d -}}
    {{- $starS := index $.SrcPtrSet $s -}}
    {{- $starD := index $.DestPtrSet $d -}}
    {{- if $starS -}}
    if {{$src}}.{{$s}} != nil {
        {{$dest}}.{{$d}} = {{if not $starD}}*{{end}}{{$src}}.{{$s}}.{{$to}}()
    } {{"\n"}}
    {{- else -}}
    {{$dest}}.{{$d}} = {{if not $starD}}*{{end}}{{$src}}.{{$s}}.{{$to}}() {{"\n"}}
    {{- end -}}
    {{- end -}}

    {{- $d := index $.MismatchSubListMap $s -}}
    {{- if $d -}}
    {{- $starS := index $.SrcPtrSet $s -}}
    {{- $starD := index $.DestPtrSet $d -}}
    if {{$src}}.{{$s}} != nil {
        {{$dest}}.{{$d}} = make([]{{if $starD}}*{{end}}{{index $.DestSubTypeMap $d}}, len({{$src}}.{{$s}}))
        for _i, _x := range {{$src}}.{{$s}} {
            {{- if (index $.SrcPtrSet $s) -}}
            if {{$src}}.{{$s}} != nil {
                {{$dest}}.{{$d}}[_i] = {{if not $starD}}*{{end}}_x.{{$to}}()
            } {{"\n"}}
            {{- else -}}
            {{$dest}}.{{$d}}[_i] = {{if not $starD}}*{{end}}_x.{{$to}}() {{"\n"}}
            {{- end -}}
        }
    } {{"\n"}}
    {{- end -}}

    {{- end -}} 
    {{- if $.WriteMethodName -}}
    {{$src}}.{{$.WriteMethodName}}({{$dest}}) {{"\n"}}
    {{- end -}}
    return {{$dest}}
}

// {{$from}} read from type {{.QualifiedDestTypeName}}, then write back to receiver
func ({{$src}} *{{.TypeName}}) {{$from}}({{$dest}} *{{.QualifiedDestTypeName}}) *{{.TypeName}} { {{"\n"}}
    {{- range $s := $.SrcFieldList -}}

    {{- $d := index $.ExactMatchMap $s -}}
    {{- if $d -}}
    {{$src}}.{{$s}} = {{$dest}}.{{$d}}{{"\n"}}
    {{- end -}}

    {{- $type := index $.DestToSrcTypeMap $s -}}
    {{- if $type -}}
    {{$src}}.{{$s}} = {{$type}}({{$src}}.{{index $.ConvMatchMap $s}}) {{"\n"}}
    {{- end -}}

    {{- $func := index $.DestToSrcFuncMap $s -}}
    {{- if $func -}}
    {{$src}}.{{$s}} = {{$src}}.{{$func}}({{$dest}}.{{index $.MismatchFuncMap $s}}) {{"\n"}}
    {{- end -}}
    
    {{- $d := index $.MismatchSubMap $s -}}
    {{- if $d -}}
    {{- $starS := index $.SrcPtrSet $s -}}
    {{- $starD := index $.DestPtrSet $s -}}
    {{$src}}.{{$s}} = {{if not $starS}}*{{end}}new({{index $.SrcSubTypeMap $s}}).{{$from}}({{if not $starD}}&{{end}}{{$dest}}.{{$d}}) {{"\n"}}
    {{- end -}}

    {{- $d := index $.MismatchSubListMap $s -}}
    {{- if $d -}}
    {{- $starS := index $.SrcPtrSet $s -}}
    {{- $starD := index $.DestPtrSet $d -}}
    if {{$dest}}.{{$d}} != nil {
        {{$src}}.{{$s}} = make([]{{if $starS}}*{{end}}{{index $.SrcSubTypeMap $d}}, len({{$dest}}.{{$d}}))
        for _i, _x := range {{$dest}}.{{$d}} {
            {{- if (index $.DestPtrSet $s) -}}
            if {{$dest}}.{{$d}} != nil {
                {{$src}}.{{$s}}[_i] = {{if not $starS}}*{{end}}_x.{{$from}}()
            } {{"\n"}}
            {{- else -}}
            {{$src}}.{{$s}}[_i] = {{if not $starS}}*{{end}}new({{index $.SrcSubTypeMap $s}}).{{$from}}({{if not $starD}}&{{end}}_x) {{"\n"}}
            {{- end -}}
        }
    } {{"\n"}}
    {{- end -}}

    {{- end -}}
    {{- if $.ReadMethodName -}}
    {{$src}}.{{$.ReadMethodName}}({{$.ReadParamPrefix}}{{$dest}}) {{"\n"}}
    {{- end -}}
    return {{$src}}
}

// ShootMap exists solely to fulfill the MapShooter interface contract
func ({{$src}} {{.TypeName}}) ShootMap() { /*noop*/ }
