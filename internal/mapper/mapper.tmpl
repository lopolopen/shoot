{{- $src := firstLower .TypeName -}}
{{- $dest := printf "%s_" (camelCase .DestTypeName) -}}
{{- $ToDest := printf "To%s" (pascalCase .DestPkgName) -}}
{{- $FromDest := printf "From%s" (pascalCase .DestPkgName) -}}
{{- if .DestPkgAlias -}}
{{- $ToDest = printf "To%s" (pascalCase .DestPkgAlias) -}}
{{- $FromDest = printf "From%s" (pascalCase .DestPkgAlias) -}}
{{- end -}}

// Code generated by "{{.CmdLine}}"; DO NOT EDIT. ({{.Version}})

package {{.PackageName}}

{{if .DestPkgAlias}}
import {{.DestPkgAlias}} "{{.DestPkgPath}}"
{{else}}
import "{{.DestPkgPath}}"
{{end}}

// {{$ToDest}} converts receiver to type {{.QualifiedDestTypeName}}
func ({{$src}} *{{.TypeName}}) {{$ToDest}}() *{{.QualifiedDestTypeName}} {
    if {{$src}} == nil {
        return nil
    }
    {{$dest}} := new({{.QualifiedDestTypeName}}) {{"\n"}}
    {{- range $p := $.DestPtrPathList -}}
    if {{$dest}}.{{$p}} == nil {
        {{$dest}}.{{$p}} = new({{index $.DestPtrTypeMap $p}})
    } {{"\n"}}
    {{- end -}}

    {{- /* ----------------- */ -}}
    {{- range $s := $.SrcFieldList -}}

    {{- $d := index $.SrcNeedReadCheckMap $s -}}
    {{- $close := false -}}
    {{- if $d -}}
    if {{condofread $src $s true}} { {{"\n"}}
    {{- $close = true -}}
    {{- end -}}

    {{- $d := index $.DestEqMatchMap $s -}}
    {{- if $d -}}
    {{$dest}}.{{$d}} = {{$src}}.{{$s}}{{"\n"}}
    {{- end -}}

    {{- $type := index $.SrcToDestTypeMap $s -}}
    {{- if $type -}}
    {{$dest}}.{{index $.ConvMatchMap $s}} = {{$type}}({{$src}}.{{$s}}) {{"\n"}}
    {{- end -}}

    {{- $func := index $.SrcToDestFuncMap $s -}}
    {{- if $func -}}
    {{$dest}}.{{index $.MismatchFuncMap $s}} = {{$src}}.{{$func}}({{$src}}.{{$s}}) {{"\n"}}
    {{- end -}}

    {{- $d := index $.DestMismatchSubMap $s -}}
    {{- if $d -}}
    {{- $starS := index $.SrcPtrSet $s -}}
    {{- $starD := index $.DestPtrSet $d -}}
    {{- if $starS -}}
    if {{$src}}.{{$s}} != nil {
        {{$dest}}.{{$d}} = {{if not $starD}}*{{end}}{{$src}}.{{$s}}.{{$ToDest}}()
    } {{"\n"}}
    {{- else -}}
    {{$dest}}.{{$d}} = {{if not $starD}}*{{end}}{{$src}}.{{$s}}.{{$ToDest}}() {{"\n"}}
    {{- end -}}
    {{- end -}}

    {{- $d := index $.DestMismatchSubListMap $s -}}
    {{- if $d -}}
    {{- $starS := index $.SrcPtrSet $s -}}
    {{- $starD := index $.DestPtrSet $d -}}
    if {{$src}}.{{$s}} != nil {
        {{$dest}}.{{$d}} = make([]{{if $starD}}*{{end}}{{index $.DestSubTypeMap $d}}, len({{$src}}.{{$s}}))
        for _i, _x := range {{$src}}.{{$s}} {
            {{$dest}}.{{$d}}[_i] = {{if not $starD}}*{{end}}_x.{{$ToDest}}()
        }
    } {{"\n"}}
    {{- end -}}

    {{- if $close -}}
    }  {{"\n"}}
    {{- end -}}

    {{- end -}} 
    {{- /* ----------------- */ -}}

    {{- if $.WriteMethodName -}}
    {{$src}}.{{$.WriteMethodName}}({{$dest}}) {{"\n"}}
    {{- end -}}
    return {{$dest}}
}

// {{$FromDest}} reads from type {{.QualifiedDestTypeName}}, then writes back to receiver and returns it
func ({{$src}} *{{.TypeName}}) {{$FromDest}}({{$dest}} *{{.QualifiedDestTypeName}}) *{{.TypeName}} {
    if {{$dest}} == nil {
        return {{$src}}
    }
    if {{$src}} == nil {
        {{$src}} = new({{.TypeName}})
    } {{"\n"}}
    {{- range $p := $.SrcPtrPathList -}}
    if {{$src}}.{{$p}} == nil {
        {{$src}}.{{$p}} = new({{index $.SrcPtrTypeMap $p}})
    } {{"\n"}}
    {{- end -}}

    {{- /* ----------------- */ -}}
    {{- range $s := $.SrcFieldList -}}

    {{- $d := index $.DestNeedReadCheckMap $s -}}
    {{- $close := false -}}
    {{- if $d -}}
    if {{condofread $dest $d false}} { {{"\n"}}
    {{- $close = true -}}
    {{- end -}}

    {{- $d := index $.SrcEqMatchMap $s -}}
    {{- if $d -}}
    {{$src}}.{{$s}} = {{$dest}}.{{$d}} {{"\n"}}
    {{- end -}}

    {{- $type := index $.DestToSrcTypeMap $s -}}
    {{- if $type -}}
    {{$src}}.{{$s}} = {{$type}}({{$dest}}.{{index $.ConvMatchMap $s}}) {{"\n"}}
    {{- end -}}

    {{- $func := index $.DestToSrcFuncMap $s -}}
    {{- if $func -}}
    {{$src}}.{{$s}} = {{$src}}.{{$func}}({{$dest}}.{{index $.MismatchFuncMap $s}}) {{"\n"}}
    {{- end -}}
    
    {{- $d := index $.MismatchSubMap $s -}}
    {{- if $d -}}
    {{- $starS := index $.SrcPtrSet $s -}}
    {{- $starD := index $.DestPtrSet $s -}}
    {{$src}}.{{$s}} = {{if not $starS}}*{{end}}new({{index $.SrcSubTypeMap $s}}).{{$FromDest}}({{if not $starD}}&{{end}}{{$dest}}.{{$d}}) {{"\n"}}
    {{- end -}}

    {{- $d := index $.MismatchSubListMap $s -}}
    {{- if $d -}}
    {{- $starS := index $.SrcPtrSet $s -}}
    {{- $starD := index $.DestPtrSet $d -}}
    if {{$dest}}.{{$d}} != nil {
        {{$src}}.{{$s}} = make([]{{if $starS}}*{{end}}{{index $.SrcSubTypeMap $s}}, len({{$dest}}.{{$d}}))
        for _i, _x := range {{$dest}}.{{$d}} {
            {{$src}}.{{$s}}[_i] = {{if not $starS}}*{{end}}new({{index $.SrcSubTypeMap $s}}).{{$FromDest}}({{if not $starD}}&{{end}}_x)
        }
    } {{"\n"}}
    {{- end -}}

    {{- if $close -}}
    }  {{"\n"}}
    {{- end -}}

    {{- end -}}
    {{- /* ----------------- */ -}}

    {{- if $.ReadMethodName -}}
    {{$src}}.{{$.ReadMethodName}}({{$.ReadParamPrefix}}{{$dest}}) {{"\n"}}
    {{- end -}}
    return {{$src}}
}

// ShootMap exists solely to fulfill the MapShooter interface contract
func ({{$src}} {{.TypeName}}) ShootMap() { /*noop*/ }
