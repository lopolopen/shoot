{{- $src := firstLower .TypeName -}}
{{- $dest := printf "%s_" (camelCase .DestTypeName) -}}
{{- $ToDest := printf "To%s" (pascalCase .DestPkgName) -}}
{{- $FromDest := printf "From%s" (pascalCase .DestPkgName) -}}
{{- if .DestPkgAlias -}}
{{- $ToDest = printf "To%s" (pascalCase .DestPkgAlias) -}}
{{- $FromDest = printf "From%s" (pascalCase .DestPkgAlias) -}}
{{- end -}}
{{- $LFormat := "%s.%s" -}}
{{- $RFormat := "%s" -}}

// Code generated by "{{.CmdLine}}"; DO NOT EDIT. ({{.Version}})

package {{.PackageName}}

{{if .DestPkgAlias}}
import {{.DestPkgAlias}} "{{.DestPkgPath}}"
{{else}}
import "{{.DestPkgPath}}"
{{end}}

// {{$ToDest}} converts receiver to type {{.QualifiedDestTypeName}}
func ({{$src}} *{{.TypeName}}) {{$ToDest}}() *{{.QualifiedDestTypeName}} {
    if {{$src}} == nil {
        return nil
    }
    {{$dest}} := new({{.QualifiedDestTypeName}}) {{"\n"}}
    {{- range $p := $.DestPtrPathList -}}
    if {{$dest}}.{{$p}} == nil {
        {{$dest}}.{{$p}} = new({{index $.DestPtrTypeMap $p}})
    } {{"\n"}}
    {{- end -}}

    {{- /* ----------------- */ -}}
    {{- range $s := $.SrcFieldList -}}

    {{- $d := index $.SrcNeedReadCheckMap $s -}}
    {{- $close := false -}}
    {{- if $d -}}
    if {{condofread $src $s true}} { {{"\n"}}
    {{- $close = true -}}
    {{- end -}}

    {{- $d := index $.DestEqMatchMap $s -}}
    {{- if $d -}}
    {{- /* {{$dest}}.{{$d}} = {{$src}}.{{$s}}{{"\n"}} */ -}}
    {{assign $dest $d (evaluate $src $s true) false $LFormat $RFormat}} {{"\n"}} 
    {{- end -}}

    {{- $type := index $.SrcToDestTypeMap $s -}}
    {{- if $type -}}
    {{- $d := index $.ConvMatchMap $s -}}
    {{- /* {{$dest}}.{{index $.ConvMatchMap $s}} = {{$type}}({{$src}}.{{$s}}) {{"\n"}} */ -}}
    {{- $rfmt := printf "%s(%%s)" $type -}}
    {{assign $dest $d (evaluate $src $s true) false $LFormat $rfmt}} {{"\n"}} 
    {{- end -}}

    {{- $func := index $.SrcToDestFuncMap $s -}}
    {{- if $func -}}
    {{- $d := index $.MismatchFuncMap $s -}}
    {{- /* {{$dest}}.{{index $.MismatchFuncMap $s}} = {{$src}}.{{$func}}({{$src}}.{{$s}}) {{"\n"}} */ -}}
    {{- $rfmt := printf "%s.%s(%%s)" $src $func -}}
    {{assign $dest $d (evaluate $src $s true) false $LFormat $rfmt}} {{"\n"}} 
    {{- end -}}

    {{- $d := index $.DestMismatchSubMap $s -}}
    {{- if $d -}}
    {{- $starS := index $.SrcPtrSet $s -}}
    {{- $starD := index $.DestPtrSet $d -}}
    {{- $rfmt := printf "%s%%s.%s()" (cond $starD "" "*") $ToDest -}}
    {{- if $starS -}}
    if {{evaluate $src $s true}} != nil {
        {{- /* {{$dest}}.{{$d}} = {{if not $starD}}*{{end}}{{$src}}.{{$s}}.{{$ToDest}}() */ -}}
        {{assign $dest $d (evaluate $src $s true) false $LFormat $rfmt}} 
    } {{"\n"}}
    {{- else -}}
    {{- /* {{$dest}}.{{$d}} = {{if not $starD}}*{{end}}{{$src}}.{{$s}}.{{$ToDest}}() {{"\n"}} */ -}}
    {{print $src $s}} := {{evaluate $src $s true}}
    {{assign $dest $d (print $src $s) false $LFormat $rfmt}} {{"\n"}}
    {{- end -}}
    {{- end -}}

    {{- $d := index $.DestMismatchSubListMap $s -}}
    {{- if $d -}}
    {{- $starS := index $.SrcPtrSet $s -}}
    {{- $starD := index $.DestPtrSet $d -}}
    {{- $subTypeD := index $.DestSubTypeMap $d -}}
    if {{evaluate $src $s true}} != nil {
        {{print $dest $d}} := make([]{{cond $starD "*" ""}}{{$subTypeD}}, len({{evaluate $src $s true}}))
        for _i, _x := range {{evaluate $src $s true}} {
            {{print $dest $d}}[_i] = {{cond $starD "" "*"}}_x.{{$ToDest}}()
        }
        {{assign $dest $d (print $dest $d) false $LFormat $RFormat}}
    } {{"\n"}}
    {{- end -}}

    {{- if $close -}}
    }  {{"\n"}}
    {{- end -}}

    {{- end -}} 
    {{- /* ----------------- */ -}}

    {{- if $.WriteMethodName -}}
    {{$src}}.{{$.WriteMethodName}}({{$dest}}) {{"\n"}}
    {{- end -}}
    return {{$dest}}
}

// {{$FromDest}} reads from type {{.QualifiedDestTypeName}}, then writes back to receiver and returns it
func ({{$src}} *{{.TypeName}}) {{$FromDest}}({{$dest}} *{{.QualifiedDestTypeName}}) *{{.TypeName}} {
    if {{$dest}} == nil {
        return {{$src}}
    }
    if {{$src}} == nil {
        {{$src}} = new({{.TypeName}})
    } {{"\n"}}
    {{- range $p := $.SrcPtrPathList -}}
    if {{$src}}.{{$p}} == nil {
        {{$src}}.{{$p}} = new({{index $.SrcPtrTypeMap $p}})
    } {{"\n"}}
    {{- end -}}

    {{- /* ----------------- */ -}}
    {{- range $s := $.SrcFieldList -}}

    {{- $d := index $.DestNeedReadCheckMap $s -}}
    {{- $close := false -}}
    {{- if $d -}}
    if {{condofread $dest $d false}} { {{"\n"}}
    {{- $close = true -}}
    {{- end -}}

    {{- $d := index $.SrcEqMatchMap $s -}}
    {{- if $d -}}
    {{- /* {{$src}}.{{$s}} = {{$dest}}.{{$d}} {{"\n"}} */ -}}
    {{assign $src $s (evaluate $dest $d false) true $LFormat $RFormat}} {{"\n"}}
    {{- end -}}

    {{- $type := index $.DestToSrcTypeMap $s -}}
    {{- if $type -}}
    {{- $d := index $.ConvMatchMap $s -}}
    {{- /* {{$src}}.{{$s}} = {{$type}}({{$dest}}.{{index $.ConvMatchMap $s}}) {{"\n"}} */ -}}
    {{- $rfmt := printf "%s(%%s)" $type -}}
    {{assign $src $s (evaluate $dest $d false) true $LFormat $rfmt}} {{"\n"}}
    {{- end -}}

    {{- $func := index $.DestToSrcFuncMap $s -}}
    {{- if $func -}}
    {{- $d := index $.MismatchFuncMap $s -}}
    {{- /* {{$src}}.{{$s}} = {{$src}}.{{$func}}({{$dest}}.{{index $.MismatchFuncMap $s}}) {{"\n"}} */ -}}
    {{- $rfmt := printf "%s.%s(%%s)" $src $func -}}
    {{assign $src $s (evaluate $dest $d false) true $LFormat $rfmt}} {{"\n"}} 
    {{- end -}}
    
    {{- $d := index $.MismatchSubMap $s -}}
    {{- if $d -}}
    {{- $starS := index $.SrcPtrSet $s -}}
    {{- $starD := index $.DestPtrSet $s -}}
    {{/* {{$src}}.{{$s}} = {{if not $starS}}*{{end}}new({{index $.SrcSubTypeMap $s}}).{{$FromDest}}({{if not $starD}}&{{end}}{{$dest}}.{{$d}}) {{"\n"}}  */}}
    {{- $subType := index $.SrcSubTypeMap $s -}}
    {{- $rfmt := printf "%snew(%s).%s(%s%%s)" (cond $starS "" "*") $subType $FromDest (cond $starD "" "&") -}} 
    {{print $dest $d}} := {{evaluate $dest $d false}}
    {{assign $src $s (print $dest $d) true $LFormat $rfmt}} {{"\n"}} 
    {{- end -}}

    {{- $d := index $.MismatchSubListMap $s -}}
    {{- if $d -}}
    {{- $starS := index $.SrcPtrSet $s -}}
    {{- $starD := index $.DestPtrSet $d -}}
    {{- $subType := index $.SrcSubTypeMap $s -}}
    if {{evaluate $dest $d false}} != nil {
        {{print $src $s}} := make([]{{if $starS}}*{{end}}{{$subType}}, len({{evaluate $dest $d false}}))
        for _i, _x := range {{evaluate $dest $d false}} {
            {{print $src $s}}[_i] = {{cond $starS "" "*"}}new({{$subType}}).{{$FromDest}}({{cond $starD "" "&"}}_x)
        }
        {{assign $src $s (print $src $s) true $LFormat $RFormat}}
    } {{"\n"}}
    {{- end -}}

    {{- if $close -}}
    }  {{"\n"}}
    {{- end -}}

    {{- end -}}
    {{- /* ----------------- */ -}}

    {{- if $.ReadMethodName -}}
    {{$src}}.{{$.ReadMethodName}}({{$.ReadParamPrefix}}{{$dest}}) {{"\n"}}
    {{- end -}}
    return {{$src}}
}

// ShootMap exists solely to fulfill the MapShooter interface contract
func ({{$src}} {{.TypeName}}) ShootMap() { /*noop*/ }
