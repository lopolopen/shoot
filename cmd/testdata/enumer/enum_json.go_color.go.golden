// Code generated by "shoot enum -json -type=Color ./testdata/enumer"; DO NOT EDIT.

package enumer

import (
	"encoding/json"
	"fmt"

	"github.com/lopolopen/shoot"
)

func _() {
	var x [1]struct{}
	_ = x[ColorRed-1]
	_ = x[ColorGreen-2]
	_ = x[ColorBlue-3]

}

const _color_all = ColorRed | ColorGreen | ColorBlue | 0

var _color_values = []Color{ColorRed, ColorGreen, ColorBlue}

var _color_strings = []string{"Red", "Green", "Blue"}

var _color_string_map = map[Color]string{
	ColorRed:   "Red",
	ColorGreen: "Green",
	ColorBlue:  "Blue",
}

var _color_value_map = map[string]Color{
	"Red":   ColorRed,
	"Green": ColorGreen,
	"Blue":  ColorBlue,
}

// String returns the string value of type Color
func (c Color) String() string {
	str, ok := _color_string_map[c]
	if ok {
		return str
	}
	if c < 0 || c > _color_all {
		return fmt.Sprintf("%d", c)
	}

	return fmt.Sprintf("%d", c)
}

func (c Color) Values() []Color {
	return _color_values
}

func (c Color) Strings() []string {
	return _color_strings
}

func (c Color) ValueMap() map[string]Color {
	return _color_value_map
}

func (c Color) StringMap() map[Color]string {
	return _color_string_map
}

// MarshalJSON implements the json.Marshaler interface for Color
func (c Color) MarshalJSON() ([]byte, error) {
	return json.Marshal(c.String())
}

// UnmarshalJSON implements the json.Unmarshaler interface for Color
func (c *Color) UnmarshalJSON(data []byte) error {
	var s_ string
	var v_ Color
	var err error
	if err = json.Unmarshal(data, &s_); err != nil {
		return fmt.Errorf("Color enum should be a string, got %s", data)
	}

	if v_, err = shoot.ParseEnum[Color](s_); err != nil {
		return err
	}
	*c = v_
	return nil
}

// ShootEnum exists solely to fulfill the EnumShooter interface contract
func (c Color) ShootEnum() { /*noop*/ }
