// Code generated by "shoot new -exp -opt -getset -json -tagcase=camel -file=user.go"; DO NOT EDIT. (v0.3.3-beta.1)

package model

import (
	"encoding/json"

	"github.com/lopolopen/shoot"
)

// NewUser constructs a new instance of type User
func NewUser(id string, name string, gender int, age int, tel string) *User {
	return &User{
		id:     id,
		name:   name,
		gender: gender,
		age:    age,
		tel:    tel,
	}
}

// With initializes this instance using the functional options pattern
func (u *User) With(opts ...shoot.Option[User, *User]) *User {
	for _, opt := range opts {
		opt(u)
	}
	return u
}

// IdOfUser is a configuration for the filed id
func IdOfUser(id_ string) shoot.Option[User, *User] {
	return func(u *User) {
		u.id = id_
	}
}

// NameOfUser is a configuration for the filed name
func NameOfUser(name_ string) shoot.Option[User, *User] {
	return func(u *User) {
		u.name = name_
	}
}

// GenderOfUser is a configuration for the filed gender
func GenderOfUser(gender_ int) shoot.Option[User, *User] {
	return func(u *User) {
		u.gender = gender_
	}
}

// AgeOfUser is a configuration for the filed age
func AgeOfUser(age_ int) shoot.Option[User, *User] {
	return func(u *User) {
		u.age = age_
	}
}

// TelOfUser is a configuration for the filed tel
func TelOfUser(tel_ string) shoot.Option[User, *User] {
	return func(u *User) {
		u.tel = tel_
	}
}

// Id gets the value of field id
func (u *User) Id() string {
	return u.id
}

// Name gets the value of field name
func (u *User) Name() string {
	return u.name
}

// Gender gets the value of field gender
func (u *User) Gender() int {
	return u.gender
}

// Age gets the value of field age
func (u *User) Age() int {
	return u.age
}

// Tel gets the value of field tel
func (u *User) Tel() string {
	return u.tel
}

// SetName sets the value of field name
func (u *User) SetName(name_ string) {
	u.name = name_
}

// SetGender sets the value of field gender
func (u *User) SetGender(gender_ int) {
	u.gender = gender_
}

// SetAge sets the value of field age
func (u *User) SetAge(age_ int) {
	u.age = age_
}

// SetTel sets the value of field tel
func (u *User) SetTel(tel_ string) {
	u.tel = tel_
}

type _User_marshal struct {
	Id     string `json:"id"`
	Name   string `json:"name"`
	Gender int    `json:"gender"`
	Age    int    `json:"age"`
	Tel    string `json:"tel"`
}
type _User_unmarshal struct {
	Name   string `json:"name"`
	Gender int    `json:"gender"`
	Age    int    `json:"age"`
	Tel    string `json:"tel"`
}

// MarshalJSON serializes type User to json bytes
func (u User) MarshalJSON() ([]byte, error) {
	data := _User_marshal{
		Id:     u.Id(),
		Name:   u.Name(),
		Gender: u.Gender(),
		Age:    u.Age(),
		Tel:    u.Tel(),
	}
	return json.Marshal(data)
}

// UnmarshalJSON deserializes json bytes to type User
func (u *User) UnmarshalJSON(data []byte) error {
	var user_ _User_unmarshal
	if err := json.Unmarshal(data, &user_); err != nil {
		return err
	}
	u.SetName(user_.Name)
	u.SetGender(user_.Gender)
	u.SetAge(user_.Age)
	u.SetTel(user_.Tel)
	return nil
}

// UserGetter is read-only interface for User type
type UserGetter interface {
	Id() string
	Name() string
	Gender() int
	Age() int
	Tel() string
}

// UserSetter is write-only interface for User type
type UserSetter interface {
	SetId(string)
	SetName(string)
	SetGender(int)
	SetAge(int)
	SetTel(string)
}

// ShootNew exists solely to fulfill the NewShooter interface contract
func (u User) ShootNew() { /*noop*/ }

// NewBook constructs a new instance of type Book
func NewBook(name string) *Book {
	return &Book{
		name: name,
	}
}

// With initializes this instance using the functional options pattern
func (b *Book) With(opts ...shoot.Option[Book, *Book]) *Book {
	for _, opt := range opts {
		opt(b)
	}
	return b
}

// NameOfBook is a configuration for the filed name
func NameOfBook(name_ string) shoot.Option[Book, *Book] {
	return func(b *Book) {
		b.name = name_
	}
}

// WritersOfBook is a configuration for the filed writers
func WritersOfBook(writers_ []string) shoot.Option[Book, *Book] {
	return func(b *Book) {
		b.writers = writers_
	}
}

// RemarksOfBook is a configuration for the filed Remarks
func RemarksOfBook(remarks_ string) shoot.Option[Book, *Book] {
	return func(b *Book) {
		b.Remarks = remarks_
	}
}

// OwnerOfBook is a configuration for the filed owner
func OwnerOfBook(owner_ *User) shoot.Option[Book, *Book] {
	return func(b *Book) {
		b.owner = owner_
	}
}

// Name gets the value of field name
func (b *Book) Name() string {
	return b.name
}

// Writers gets the value of field writers
func (b *Book) Writers() []string {
	return b.writers
}

// Owner gets the value of field owner
func (b *Book) Owner() *User {
	return b.owner
}

// SetName sets the value of field name
func (b *Book) SetName(name_ string) {
	b.name = name_
}

// SetWriters sets the value of field writers
func (b *Book) SetWriters(writers_ []string) {
	b.writers = writers_
}

// SetOwner sets the value of field owner
func (b *Book) SetOwner(owner_ *User) {
	b.owner = owner_
}

type _Book_marshal struct {
	Name    string   `json:"name"`
	Writers []string `json:"writers"`
	Owner   *User    `json:"owner"`
	Remarks string   `json:"remarks"`
}
type _Book_unmarshal struct {
	Name    string   `json:"name"`
	Writers []string `json:"writers"`
	Owner   *User    `json:"owner"`
	Remarks string   `json:"remarks"`
}

// MarshalJSON serializes type Book to json bytes
func (b Book) MarshalJSON() ([]byte, error) {
	data := _Book_marshal{
		Name:    b.Name(),
		Writers: b.Writers(),
		Owner:   b.Owner(),
		Remarks: b.Remarks,
	}
	return json.Marshal(data)
}

// UnmarshalJSON deserializes json bytes to type Book
func (b *Book) UnmarshalJSON(data []byte) error {
	var book_ _Book_unmarshal
	if err := json.Unmarshal(data, &book_); err != nil {
		return err
	}
	b.SetName(book_.Name)
	b.SetWriters(book_.Writers)
	b.SetOwner(book_.Owner)
	b.Remarks = book_.Remarks
	return nil
}

// BookGetter is read-only interface for Book type
type BookGetter interface {
	Name() string
	Writers() []string
	Owner() *User
}

// BookSetter is write-only interface for Book type
type BookSetter interface {
	SetName(string)
	SetWriters([]string)
	SetOwner(*User)
}

// ShootNew exists solely to fulfill the NewShooter interface contract
func (b Book) ShootNew() { /*noop*/ }

// NewAddress constructs a new instance of type Address
func NewAddress(province string, city string, district string, street string) *Address {
	return &Address{
		Province: province,
		City:     city,
		District: district,
		Street:   street,
	}
}

// With initializes this instance using the functional options pattern
func (a *Address) With(opts ...shoot.Option[Address, *Address]) *Address {
	for _, opt := range opts {
		opt(a)
	}
	return a
}

// ProvinceOfAddress is a configuration for the filed Province
func ProvinceOfAddress(province_ string) shoot.Option[Address, *Address] {
	return func(a *Address) {
		a.Province = province_
	}
}

// CityOfAddress is a configuration for the filed City
func CityOfAddress(city_ string) shoot.Option[Address, *Address] {
	return func(a *Address) {
		a.City = city_
	}
}

// DistrictOfAddress is a configuration for the filed District
func DistrictOfAddress(district_ string) shoot.Option[Address, *Address] {
	return func(a *Address) {
		a.District = district_
	}
}

// StreetOfAddress is a configuration for the filed Street
func StreetOfAddress(street_ string) shoot.Option[Address, *Address] {
	return func(a *Address) {
		a.Street = street_
	}
}

type _Address_marshal struct {
	Province string `json:"province"`
	City     string `json:"city"`
	District string `json:"district"`
	Street   string `json:"street"`
}
type _Address_unmarshal struct {
	Province string `json:"province"`
	City     string `json:"city"`
	District string `json:"district"`
	Street   string `json:"street"`
}

// MarshalJSON serializes type Address to json bytes
func (a Address) MarshalJSON() ([]byte, error) {
	data := _Address_marshal{
		Province: a.Province,
		City:     a.City,
		District: a.District,
		Street:   a.Street,
	}
	return json.Marshal(data)
}

// UnmarshalJSON deserializes json bytes to type Address
func (a *Address) UnmarshalJSON(data []byte) error {
	var address_ _Address_unmarshal
	if err := json.Unmarshal(data, &address_); err != nil {
		return err
	}
	a.Province = address_.Province
	a.City = address_.City
	a.District = address_.District
	a.Street = address_.Street
	return nil
}

// ShootNew exists solely to fulfill the NewShooter interface contract
func (a Address) ShootNew() { /*noop*/ }
