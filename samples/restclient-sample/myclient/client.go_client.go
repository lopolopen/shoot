// Code generated by "shoot rest -type=Client"; DO NOT EDIT.

package myclient

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"time"

	"github.com/lopolopen/shoot"
)

type client struct {
	client *http.Client
	conf   *shoot.RestConf
}

func (c *client) Get(ctx context.Context, key string) (*KV, error) {
	path_ := "/get"

	url_, err := url.JoinPath(c.conf.BaseURL(), path_)
	if err != nil {
		return nil, err
	}

	req_, err := http.NewRequestWithContext(ctx, "GET", url_, nil)
	if err != nil {
		return nil, err
	}

	query_ := req_.URL.Query()
	query_.Set("key", fmt.Sprintf("%v", key))
	req_.URL.RawQuery = query_.Encode()

	req_.Header.Add("Accept", "application/json")
	req_.Header.Add("Authorization", "Basic dXNlcm5hbWU6cGFzc3dvcmQ=")

	resp_, err := c.client.Do(req_)
	if err != nil {
		return nil, err
	}
	defer resp_.Body.Close()

	body_, err := io.ReadAll(resp_.Body)
	if err != nil {
		return nil, err
	}
	var result_ KV
	err = json.Unmarshal(body_, &result_)
	if err != nil {
		return nil, err
	}
	return &result_, nil
}

func (c *client) Set(ctx context.Context, kv *KV) error {
	path_ := "/set"

	url_, err := url.JoinPath(c.conf.BaseURL(), path_)
	if err != nil {
		return err
	}

	bodyJson_, err := json.Marshal(kv)
	if err != nil {
		return err
	}

	req_, err := http.NewRequestWithContext(ctx, "POST", url_, bytes.NewReader(bodyJson_))
	if err != nil {
		return err
	}

	req_.Header.Add("Accept", "application/json")
	req_.Header.Add("Authorization", "Basic dXNlcm5hbWU6cGFzc3dvcmQ=")
	req_.Header.Add("Content-Type", "application/json")

	resp_, err := c.client.Do(req_)
	if err != nil {
		return err
	}
	defer resp_.Body.Close()

	return nil
}

// ConfigHTTPClient allows customization of the underlying http.Client.
func (c *client) ConfigHTTPClient(config func(*http.Client)) Client {
	config(c.client)
	return c
}

// ShootRest exists solely to fulfill the RestShooter interface contract.
func (c *client) ShootRest() { /*noop*/ }

func init() {
	shoot.Register(func(conf shoot.RestConf) Client {
		return &client{
			conf: &conf,
			client: &http.Client{
				Timeout:   time.Duration(conf.Timeout()) * time.Second,
				Transport: conf.BuildMiddleware(),
			},
		}
	})
}
