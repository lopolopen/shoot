// Code generated by "shoot rest -type=Client"; DO NOT EDIT. (v0.7.0-beta.2)

package xclient

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"restclientexample/xclient/dto"
	"strings"
	"time"

	"github.com/lopolopen/shoot"
)

type client struct {
	client *http.Client
	conf   *shoot.RestConf
}

func (c *client) GetUser(ctx context.Context, userID string, pageSize int, pageIdx *int) (*User, *http.Response, error) {
	path_ := "/users/{id}"
	path_ = strings.Replace(path_, "{id}", fmt.Sprintf("%v", userID), 1)

	url_, err := url.JoinPath(c.conf.BaseURL(), path_)
	if err != nil {
		return nil, nil, err
	}

	req_, err := http.NewRequestWithContext(ctx, "GET", url_, nil)
	if err != nil {
		return nil, nil, err
	}

	query_ := req_.URL.Query()
	query_.Set("size", fmt.Sprintf("%v", pageSize))
	if pageIdx != nil {
		query_.Set("page_idx", fmt.Sprintf("%v", *pageIdx))
	}
	req_.URL.RawQuery = query_.Encode()

	req_.Header.Add("Accept", "application/json")
	req_.Header.Add("Tenant-Id", "123")

	resp_, err := c.client.Do(req_)
	if err != nil {
		return nil, nil, err
	}
	defer resp_.Body.Close()

	switch {
	case resp_.StatusCode >= 500:
		body_, _ := io.ReadAll(resp_.Body)
		err = fmt.Errorf("server error %d: %s", resp_.StatusCode, string(body_))
	case resp_.StatusCode >= 400:
		body_, _ := io.ReadAll(resp_.Body)
		err = fmt.Errorf("client error %d: %s", resp_.StatusCode, string(body_))
	case resp_.StatusCode >= 300 || resp_.StatusCode < 200:
		err = fmt.Errorf("not supported error %d", resp_.StatusCode)
	}
	if err != nil {
		return nil, resp_, err
	}

	var r_ User
	err = json.NewDecoder(resp_.Body).Decode(&r_)
	if err == io.EOF {
		err = nil //ignore EOF errors caused by empty response body
	}
	if err != nil {
		return nil, resp_, err
	}
	return &r_, resp_, nil
}

func (c *client) QueryUsers(ctx context.Context, req dto.QueryUsersReq) (*dto.QueryUsersResp, *http.Response, error) {
	path_ := "/users"

	url_, err := url.JoinPath(c.conf.BaseURL(), path_)
	if err != nil {
		return nil, nil, err
	}

	bodyJson_, err := json.Marshal(req)
	if err != nil {
		return nil, nil, err
	}

	req_, err := http.NewRequestWithContext(ctx, "POST", url_, bytes.NewReader(bodyJson_))
	if err != nil {
		return nil, nil, err
	}

	req_.Header.Add("Accept", "application/json")
	req_.Header.Add("Content-Type", "application/json")
	req_.Header.Add("Tenant-Id", "123")

	resp_, err := c.client.Do(req_)
	if err != nil {
		return nil, nil, err
	}
	defer resp_.Body.Close()

	switch {
	case resp_.StatusCode >= 500:
		body_, _ := io.ReadAll(resp_.Body)
		err = fmt.Errorf("server error %d: %s", resp_.StatusCode, string(body_))
	case resp_.StatusCode >= 400:
		body_, _ := io.ReadAll(resp_.Body)
		err = fmt.Errorf("client error %d: %s", resp_.StatusCode, string(body_))
	case resp_.StatusCode >= 300 || resp_.StatusCode < 200:
		err = fmt.Errorf("not supported error %d", resp_.StatusCode)
	}
	if err != nil {
		return nil, resp_, err
	}

	var r_ dto.QueryUsersResp
	err = json.NewDecoder(resp_.Body).Decode(&r_)
	if err == io.EOF {
		err = nil //ignore EOF errors caused by empty response body
	}
	if err != nil {
		return nil, resp_, err
	}
	return &r_, resp_, nil
}

func (c *client) QueryBooks(ctx context.Context, req dto.QueryBooksReq) (*dto.QueryBooksResp, *http.Response, error) {
	path_ := "/books"

	url_, err := url.JoinPath(c.conf.BaseURL(), path_)
	if err != nil {
		return nil, nil, err
	}

	req_, err := http.NewRequestWithContext(ctx, "GET", url_, nil)
	if err != nil {
		return nil, nil, err
	}

	query_ := req_.URL.Query()
	query_.Set("name", fmt.Sprintf("%v", req.Name()))
	query_.Set("lang", fmt.Sprintf("%v", req.Language()))
	query_.Set("page_size", fmt.Sprintf("%v", req.PageSize))
	query_.Set("pageIndex", fmt.Sprintf("%v", req.PageIndex))
	req_.URL.RawQuery = query_.Encode()

	req_.Header.Add("Accept", "application/json")
	req_.Header.Add("Tenant-Id", "123")

	resp_, err := c.client.Do(req_)
	if err != nil {
		return nil, nil, err
	}
	defer resp_.Body.Close()

	switch {
	case resp_.StatusCode >= 500:
		body_, _ := io.ReadAll(resp_.Body)
		err = fmt.Errorf("server error %d: %s", resp_.StatusCode, string(body_))
	case resp_.StatusCode >= 400:
		body_, _ := io.ReadAll(resp_.Body)
		err = fmt.Errorf("client error %d: %s", resp_.StatusCode, string(body_))
	case resp_.StatusCode >= 300 || resp_.StatusCode < 200:
		err = fmt.Errorf("not supported error %d", resp_.StatusCode)
	}
	if err != nil {
		return nil, resp_, err
	}

	var r_ dto.QueryBooksResp
	err = json.NewDecoder(resp_.Body).Decode(&r_)
	if err == io.EOF {
		err = nil //ignore EOF errors caused by empty response body
	}
	if err != nil {
		return nil, resp_, err
	}
	return &r_, resp_, nil
}

func (c *client) QueryBooks0(ctx context.Context, req QueryBooksReq) (*dto.QueryBooksResp, *http.Response, error) {
	path_ := "/books"

	url_, err := url.JoinPath(c.conf.BaseURL(), path_)
	if err != nil {
		return nil, nil, err
	}

	req_, err := http.NewRequestWithContext(ctx, "GET", url_, nil)
	if err != nil {
		return nil, nil, err
	}

	query_ := req_.URL.Query()
	if req.Name() != nil {
		query_.Set("name", fmt.Sprintf("%v", *req.Name()))
	}
	query_.Set("lang", fmt.Sprintf("%v", req.Language()))
	query_.Set("page_size", fmt.Sprintf("%v", req.PageSize))
	if req.PageIndex != nil {
		query_.Set("pageIndex", fmt.Sprintf("%v", *req.PageIndex))
	}
	req_.URL.RawQuery = query_.Encode()

	req_.Header.Add("Accept", "application/json")
	req_.Header.Add("Tenant-Id", "123")

	resp_, err := c.client.Do(req_)
	if err != nil {
		return nil, nil, err
	}
	defer resp_.Body.Close()

	switch {
	case resp_.StatusCode >= 500:
		body_, _ := io.ReadAll(resp_.Body)
		err = fmt.Errorf("server error %d: %s", resp_.StatusCode, string(body_))
	case resp_.StatusCode >= 400:
		body_, _ := io.ReadAll(resp_.Body)
		err = fmt.Errorf("client error %d: %s", resp_.StatusCode, string(body_))
	case resp_.StatusCode >= 300 || resp_.StatusCode < 200:
		err = fmt.Errorf("not supported error %d", resp_.StatusCode)
	}
	if err != nil {
		return nil, resp_, err
	}

	var r_ dto.QueryBooksResp
	err = json.NewDecoder(resp_.Body).Decode(&r_)
	if err == io.EOF {
		err = nil //ignore EOF errors caused by empty response body
	}
	if err != nil {
		return nil, resp_, err
	}
	return &r_, resp_, nil
}

func (c *client) QueryBooks2(ctx context.Context, groupID int, params map[string]interface{}) (*dto.Book, *http.Response, error) {
	path_ := "/groups/{id}/books"
	path_ = strings.Replace(path_, "{id}", fmt.Sprintf("%v", groupID), 1)

	url_, err := url.JoinPath(c.conf.BaseURL(), path_)
	if err != nil {
		return nil, nil, err
	}

	req_, err := http.NewRequestWithContext(ctx, "GET", url_, nil)
	if err != nil {
		return nil, nil, err
	}

	query_ := req_.URL.Query()
	for k, v := range params {
		query_.Set(k, fmt.Sprintf("%v", v))
	}
	req_.URL.RawQuery = query_.Encode()

	req_.Header.Add("Accept", "application/json")
	req_.Header.Add("Tenant-Id", "123")

	resp_, err := c.client.Do(req_)
	if err != nil {
		return nil, nil, err
	}
	defer resp_.Body.Close()

	switch {
	case resp_.StatusCode >= 500:
		body_, _ := io.ReadAll(resp_.Body)
		err = fmt.Errorf("server error %d: %s", resp_.StatusCode, string(body_))
	case resp_.StatusCode >= 400:
		body_, _ := io.ReadAll(resp_.Body)
		err = fmt.Errorf("client error %d: %s", resp_.StatusCode, string(body_))
	case resp_.StatusCode >= 300 || resp_.StatusCode < 200:
		err = fmt.Errorf("not supported error %d", resp_.StatusCode)
	}
	if err != nil {
		return nil, resp_, err
	}

	var r_ dto.Book
	err = json.NewDecoder(resp_.Body).Decode(&r_)
	if err == io.EOF {
		err = nil //ignore EOF errors caused by empty response body
	}
	if err != nil {
		return nil, resp_, err
	}
	return &r_, resp_, nil
}

func (c *client) UpdateUser(ctx context.Context, id int, user User) (*http.Response, error) {
	path_ := "/users/{id}"
	path_ = strings.Replace(path_, "{id}", fmt.Sprintf("%v", id), 1)

	url_, err := url.JoinPath(c.conf.BaseURL(), path_)
	if err != nil {
		return nil, err
	}

	bodyJson_, err := json.Marshal(user)
	if err != nil {
		return nil, err
	}

	req_, err := http.NewRequestWithContext(ctx, "PUT", url_, bytes.NewReader(bodyJson_))
	if err != nil {
		return nil, err
	}

	req_.Header.Add("Accept", "application/json")
	req_.Header.Add("Content-Type", "application/json")
	req_.Header.Add("Tenant-Id", "123")

	resp_, err := c.client.Do(req_)
	if err != nil {
		return nil, err
	}
	defer resp_.Body.Close()

	switch {
	case resp_.StatusCode >= 500:
		body_, _ := io.ReadAll(resp_.Body)
		err = fmt.Errorf("server error %d: %s", resp_.StatusCode, string(body_))
	case resp_.StatusCode >= 400:
		body_, _ := io.ReadAll(resp_.Body)
		err = fmt.Errorf("client error %d: %s", resp_.StatusCode, string(body_))
	case resp_.StatusCode >= 300 || resp_.StatusCode < 200:
		err = fmt.Errorf("not supported error %d", resp_.StatusCode)
	}
	if err != nil {
		return resp_, err
	}
	return resp_, nil
}

// ConfigHTTPClient allows customization of the underlying http.Client.
func (c *client) ConfigHTTPClient(config func(*http.Client)) Client {
	config(c.client)
	return c
}

// ShootRest exists solely to fulfill the RestShooter interface contract.
func (c *client) ShootRest() { /*noop*/ }

func init() {
	shoot.Register(func(conf shoot.RestConf) Client {
		return &client{
			conf: &conf,
			client: &http.Client{
				Timeout:   time.Duration(conf.Timeout()) * time.Second,
				Transport: conf.BuildMiddleware(),
			},
		}
	})
}
